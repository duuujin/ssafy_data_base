# 읽기 전용 필드
- 서버가 조회 요청에 대한 응답 시에만 값을 표시하는 필드

# 읽기 전용 필드 사용 목적
- 클라이언트 측에서 직접 수정하면 안 되는 경우
- 서버 로직에 의해 자동 생성,관리되는 값 활용
- 입력은 받지 않지만 정보를 제공해야 하는 경우
- 새로운 필드 값(추가 계산, 가공)을 만들어 제공해야 하는 경우

# 읽기 전용 필드 특징 및 주의사항
- 유효성 검사에서 제외됨
    - 읽기 전용 필드는 클라이언트가 보내는 요청 데이터에서 고려되지 않으므로, 유효성 검사 대상에서 제외됨
    - 즉, 클라이언트가 해당 필드에 값을 넣어도 무시되며 검증 오류를 일으키지 않음
- 생성,수정 요청 모두에서 적용 가능
    - 읽기 전용 필드라 해서 생성(POST) 단계에서만 무의미한 것은 아님
    - 수정(PUT) 요청에서도 해당 필드는 여전히 클라이언트 입력을 받지 않고, 응답 시에만 노출됨

# SerializerMethodField
- Serializer에서 추가적인 데이터 가공을 하고 싶을 때 사용
- 예를 들어, 특정 필드 값을 조합해 새로운 문자열필드를 만들거나, 부가적인 계산 (비율, 합계, 평균)을 하는 경우에 활용할 수 있습니다

# SerializerMethodField 사용 목적
- 유연성
    - 다양한 계산 로직을 손쉽게 추가 가능
- 가독성
    - 데이터 변환 과정을 Serializer 내부 메서드로 명확히 분리
- 유지보수성
    - view나 model에 비해 Serializer 측 로직 변경이 용이
- 일관성
    - view에서 별도로 data 수정 없이도 직렬화 결과를 제어

# 문서화
# OpenAPI Specification ( OAS )
- RESTful API를 설명하고 시각화하는 표준화된 방법

# 설계 우선 접근법
- OAS의 핵심 이점
- API를 먼저 설계하고 명세를 작성한 후, 이를 기반으로 코드를 구현하는 방식
- API의 일관성을 유지하고, API 사용자는 더 쉽게 API를 이해하고 사용할 수 있음
- 또한, OAS를 사용하면 API가 어떻게 작동하는지를 시각적으로 보여주는 문서를 생성할 수 있으며, 이는 API를 이해하고 테스트하는 데 매우 유용
- 이런 목적으로 사용되는 도구가 Swagger-UI 또는 ReDoc

# View와 Serializer
- view나 queryset 로직에서는 비즈니스 로직(데이터 가공, annotate, 필터링)을 처리
- serializer는 그 결과물을 직렬화하는 역할에 집중하는 것이 일반적인 권장사항
- 복잡한 query나 로직은 View 함수에서 진행
    - 여러 모델을 조인하거나 복잡한 집계가 필요한 경우 View 함수에서 처리
    - 필요한 경우 View 함수에서 select_related()나 prefetch_related()를 사용하여 query를 최적화

# 왜 DRF를 배웠는가
- 백엔드와 프론트엔드의 분리 경험
    - 기존 Django 템플릿 기반의 서버 렌더링 방식을 벗어나, 백엔드(데이터,로직)와 프론트엔드(UI)를 명확히 분리하는 패턴을 간접적으로 체험
- 표준화된 API 구축 역량 확보
    - DRF를 통해 RESTful API를 손쉽게 만들고 관리하는 방법을 학습했는데, 이는 다양한 클라이언트(웹, 모바일 앱, 외부 서비스)와 연동하는데 필수적인 능력
- 프론트엔드 기술과의 연결 고리
    - 앞으로 학습할 Javascript 및 Vue는 주로 API를 통해 데이터를 받아와 화면을 구성함
    - DRF로 구축한 일관된 API는 Vue 등 프론트엔드 프레임워크와 매끄럽게 호환됨
    